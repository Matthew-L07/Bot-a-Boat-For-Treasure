"""
Generate placeholder weights for testing before training
This creates a properly formatted weights file with random initialization
"""

import json
import numpy as np
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent
json_path = BASE_DIR / "dqn_weights.json"
lua_path = BASE_DIR.parent / "src" / "ai" / "navigation" / "DqnWeights.lua"


def xavier_init(fan_in: int, fan_out: int, shape: tuple) -> np.ndarray:
    """Xavier/Glorot initialization"""
    limit = np.sqrt(6.0 / (fan_in + fan_out))
    return np.random.uniform(-limit, limit, shape)


def generate_placeholder_weights(state_dim: int = 9, num_actions: int = 7, hidden_dim: int = 128):
    """
    Generate placeholder weights with proper Xavier initialization
    Architecture: state_dim -> hidden_dim -> hidden_dim -> num_actions
    """
    print(f"Generating placeholder weights:")
    print(f"  State dimension: {state_dim}")
    print(f"  Action space: {num_actions}")
    print(f"  Hidden dimension: {hidden_dim}")
    print(f"  Architecture: {state_dim} -> {hidden_dim} -> {hidden_dim} -> {num_actions}")
    
    layers = []
    
    # Layer 1: state_dim -> hidden_dim
    W1 = xavier_init(state_dim, hidden_dim, (hidden_dim, state_dim))
    b1 = np.zeros(hidden_dim)
    
    layers.append({
        'W': W1.tolist(),
        'b': b1.tolist(),
    })
    print(f"  Layer 1: {W1.shape}")
    
    # Layer 2: hidden_dim -> hidden_dim
    W2 = xavier_init(hidden_dim, hidden_dim, (hidden_dim, hidden_dim))
    b2 = np.zeros(hidden_dim)
    
    layers.append({
        'W': W2.tolist(),
        'b': b2.tolist(),
    })
    print(f"  Layer 2: {W2.shape}")
    
    # Layer 3: hidden_dim -> num_actions
    W3 = xavier_init(hidden_dim, num_actions, (num_actions, hidden_dim))
    b3 = np.zeros(num_actions)
    
    layers.append({
        'W': W3.tolist(),
        'b': b3.tolist(),
    })
    print(f"  Layer 3: {W3.shape}")
    
    weights_obj = {
        'state_dim': state_dim,
        'num_actions': num_actions,
        'layers': layers,
    }
    
    return weights_obj


def export_to_lua(weights_obj: dict, output_path: Path):
    """Export weights to Lua format"""
    minified_json = json.dumps(weights_obj, separators=(',', ':'))
    
    lua_code = f"""local HttpService = game:GetService("HttpService")

-- PLACEHOLDER WEIGHTS - Generated by generate_placeholder_weights.py
-- These are randomly initialized and should be replaced with trained weights
-- Model: {weights_obj['state_dim']}-dim state, {weights_obj['num_actions']} actions
-- Architecture: {weights_obj['state_dim']} -> 128 -> 128 -> {weights_obj['num_actions']}

local json = [=[{minified_json}]=]

local Weights = HttpService:JSONDecode(json)

return Weights
"""
    
    output_path.write_text(lua_code)
    print(f"\nExported to {output_path}")
    
    size_kb = output_path.stat().st_size / 1024
    print(f"File size: {size_kb:.1f} KB")


def main():
    print("=" * 60)
    print("GENERATING PLACEHOLDER WEIGHTS")
    print("=" * 60)
    print()
    
    # Generate weights
    weights_obj = generate_placeholder_weights(state_dim=9, num_actions=7, hidden_dim=128)
    
    # Save JSON
    json_path.write_text(json.dumps(weights_obj, indent=2))
    print(f"\nSaved JSON to {json_path}")
    
    # Export to Lua
    export_to_lua(weights_obj, lua_path)
    
    print("\n" + "=" * 60)
    print("IMPORTANT: These are placeholder weights!")
    print("The bot will take random actions until you:")
    print("  1. Collect training data by running the bot")
    print("  2. Run train_dqn.py to train the model")
    print("  3. Run export_weights.py to export trained weights")
    print("=" * 60)


if __name__ == "__main__":
    main()