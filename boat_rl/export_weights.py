import json
import torch
from pathlib import Path

BASE_DIR = Path(__file__).resolve().parent

# Input: PyTorch model checkpoint
weights_pth_path = BASE_DIR / "dqn_weights_best.pth"  # or "dqn_weights.pth"

# Output: JSON file for Lua
json_path = BASE_DIR / "dqn_weights.json"

# Output: Lua file
lua_path = BASE_DIR.parent / "src" / "ai" / "navigation" / "DqnWeights.lua"


def pytorch_to_json(checkpoint_path: Path) -> dict:
    """
    Convert PyTorch checkpoint to JSON-serializable format
    Expected checkpoint structure:
    {
        'state_dim': int,
        'num_actions': int,
        'model_state_dict': OrderedDict,
        ...
    }
    """
    # Load checkpoint
    checkpoint = torch.load(checkpoint_path, map_location='cpu')
    
    state_dict = checkpoint['model_state_dict']
    state_dim = checkpoint.get('state_dim', 11)
    num_actions = checkpoint.get('num_actions', 5)
    
    print(f"Converting model with state_dim={state_dim}, num_actions={num_actions}")
    
    # Extract layers from sequential network
    # Expected keys: net.0.weight, net.0.bias (layer 1), net.2.weight, net.2.bias (layer 2), etc.
    layers = []
    
    # Layer 1: Linear(state_dim, 128)
    W1 = state_dict['net.0.weight'].cpu().numpy()  # [128, state_dim]
    b1 = state_dict['net.0.bias'].cpu().numpy()    # [128]
    
    layers.append({
        'W': W1.tolist(),  # Convert to list for JSON
        'b': b1.tolist(),
    })
    
    # Layer 2: Linear(128, 128)
    W2 = state_dict['net.2.weight'].cpu().numpy()  # [128, 128]
    b2 = state_dict['net.2.bias'].cpu().numpy()    # [128]
    
    layers.append({
        'W': W2.tolist(),
        'b': b2.tolist(),
    })
    
    # Layer 3: Linear(128, num_actions)
    W3 = state_dict['net.4.weight'].cpu().numpy()  # [num_actions, 128]
    b3 = state_dict['net.4.bias'].cpu().numpy()    # [num_actions]
    
    layers.append({
        'W': W3.tolist(),
        'b': b3.tolist(),
    })
    
    # Validate dimensions
    assert W1.shape == (128, state_dim), f"Layer 1 weight shape mismatch: {W1.shape}"
    assert W2.shape == (128, 128), f"Layer 2 weight shape mismatch: {W2.shape}"
    assert W3.shape == (num_actions, 128), f"Layer 3 weight shape mismatch: {W3.shape}"
    
    print(f"Layer 1: {W1.shape} ({state_dim} -> 128)")
    print(f"Layer 2: {W2.shape} (128 -> 128)")
    print(f"Layer 3: {W3.shape} (128 -> {num_actions})")
    
    weights_obj = {
        'state_dim': state_dim,
        'num_actions': num_actions,
        'layers': layers,
    }
    
    return weights_obj


def export_to_lua(weights_obj: dict, output_path: Path):
    """
    Export weights to Lua format using JSON encoding
    This creates a Lua file that uses HttpService:JSONDecode
    """
    # Minify JSON to reduce file size
    minified_json = json.dumps(weights_obj, separators=(',', ':'))
    
    lua_code = f"""local HttpService = game:GetService("HttpService")

-- AUTO-GENERATED by boat_rl/export_weights.py. Do not edit by hand.
-- Model: {weights_obj['state_dim']}-dim state, {weights_obj['num_actions']} actions
-- Architecture: {weights_obj['state_dim']} -> 128 -> 128 -> {weights_obj['num_actions']}

local json = [=[{minified_json}]=]

local Weights = HttpService:JSONDecode(json)

return Weights
"""
    
    output_path.write_text(lua_code)
    print(f"Exported Lua weights to {output_path}")
    
    # Print file size
    size_kb = output_path.stat().st_size / 1024
    print(f"File size: {size_kb:.1f} KB")


def main():
    # Check if checkpoint exists
    if not weights_pth_path.exists():
        print(f"ERROR: Checkpoint not found at {weights_pth_path}")
        print("Please run train_dqn.py first to generate weights")
        return
    
    print(f"Loading weights from {weights_pth_path}")
    
    # Convert PyTorch to JSON
    weights_obj = pytorch_to_json(weights_pth_path)
    
    # Save intermediate JSON (optional, for debugging)
    json_path.write_text(json.dumps(weights_obj, indent=2))
    print(f"Saved JSON weights to {json_path}")
    
    # Export to Lua
    export_to_lua(weights_obj, lua_path)
    
    print("\nExport complete!")
    print(f"  State dimension: {weights_obj['state_dim']}")
    print(f"  Action space: {weights_obj['num_actions']}")
    print(f"  Layers: {len(weights_obj['layers'])}")


if __name__ == "__main__":
    main()
